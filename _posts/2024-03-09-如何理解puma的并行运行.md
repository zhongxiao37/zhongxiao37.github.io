---
layout: default
title: 如何理解Puma的并行运行
date: 2024-03-09 15:42 +0800
categories: puma
---

Puma 是一个基于 rack 的 web server，在 Readme 中，它提到即使有 GVL 的存在，它还是能够实现 IO waiting 方面的 parallel。为什么？

```md
## Built For Speed & Parallelism

Puma is a server for Rack-powered HTTP applications written in Ruby. It is:

Multi-threaded. Each request is served in a separate thread. This helps you serve more requests per second with less memory use.
Multi-process. "Pre-forks" in cluster mode, using less memory per-process thanks to copy-on-write memory.
Standalone. With SSL support, zero-downtime rolling restarts and a built-in request bufferer, you can deploy Puma without any reverse proxy.
Battle-tested. Our HTTP parser is inherited from Mongrel and has over 15 years of production use. Puma is currently the most popular Ruby webserver, and is the default server for Ruby on Rails.
Originally designed as a server for Rubinius, Puma also works well with Ruby (MRI) and JRuby.

On MRI, there is a Global VM Lock (GVL) that ensures only one thread can run Ruby code at a time. But if you're doing a lot of blocking IO (such as HTTP calls to external APIs like Twitter), Puma still improves MRI's throughput by allowing IO waiting to be done in parallel. Truly parallel Ruby implementations (TruffleRuby, JRuby) don't have this limitation.
```

## 多进程

[https://www.speedshop.co/2020/05/11/the-ruby-gvl-and-scaling.html](https://www.speedshop.co/2020/05/11/the-ruby-gvl-and-scaling.html)一文中展示了，在多进程情况下，可以实现真实的并行，即多个 worker 同时处理不同的事情。

## 多线程

由于 GVL 的存在，每个进程中只能有一个线程去获取 GVL 并运行 Ruby 代码。对于 IO blocking 的操作，Ruby 引入了`Reactor`模式实现的 non-blocking IO。这背后是通过 IO.select，以及 puma 4 中切换成`nio4r`，来实现的。这样的结果是，遇到 IO blocking 的操作，系统会释放线程，处理其他操作，直到 IO ready 之后再处理。所以，即使有 GVL，多线程也可以提升并发量。

## Ruby 中的 GVL

## Reference

1. [https://www.speedshop.co/2020/05/11/the-ruby-gvl-and-scaling.html](https://www.speedshop.co/2020/05/11/the-ruby-gvl-and-scaling.html)
